#! /usr/bin/env ruby

require 'thor'
require 'csv'

class CSVP < Thor

  option :output_file, required: true, desc: 'filename to output the spreadshee too', aliases: '-o'
  desc 'brand', 'For products that have a brand, ensure it has a correct brand taxonomy'
  def brand(csv)
    stats = Hash.new(0)
    out_csv = read_table(csv).each do |row|
      brand = row['brand'].to_s.strip.capitalize
      (stats[:blank] += 1) && next if brand.empty?

      taxonomies = row['taxonomies'].to_s
      # Check for correct brand taxon and next. Rules out correct brands
      (stats[:ok] += 1) && next if taxonomies.include?("Brand>#{brand}")

      if taxonomies.match?(/brand>/i) # is there already a brand t. heir.?
        row['taxonomies'] = taxonomies.split('|').map do |heirarchy|
          # Correct brand if its there, rules out bad brand taxon
          heirarchy.match?(/\Abrand>/i) ? "Brand>#{brand}" : heirarchy
        end.join('|')
        stats[:corrected] += 1
      else
        # Only possible state left is missing brand, so add it
        row['taxonomies'] = taxonomies + "|Brand>#{brand}"
        stats[:added] += 1
      end
    end

    write_table(out_csv, options)

    puts 'Brands ensured. Products stats:'
    put_stats(stats)
  end

  option :output_file, required: true, desc: 'filename to output the spreadshee too', aliases: '-o'
  desc 'intersect', 'takes intersection A of B, outputing only rows in B that are in both A and B'
  long_desc <<-LONGDESC
  compares by sku header by default, but you can change that by adding another argument after the second spreadsheet
  LONGDESC
  def intersect(a, b, compare_header = 'sku')
    a = read_table(a)
    b = read_table(b)
    common = a[compare_header] & b[compare_header]

    c = CSV::Table.new(b.select { |row| common.include?(row[compare_header]) })
    write_table(c, options)
  end

  option :output_file, required: true, desc: 'filename to output the spreadshee too', aliases: '-o'
  desc 'diff', 'takes two spreadsheets, A and B, and leaves only rows A has that B doesn\'t'
  long_desc <<-LONGDESC
  compares by sku header by default, but you can change that by adding another argument after the second spreadsheet
  LONGDESC
  def diff(a, b, compare_header = 'sku')
    a = read_table(a)
    b = read_table(b)

    diff = a[compare_header] - b[compare_header]
    c = CSV::Table.new(a.select { |row| diff.include?(row[compare_header]) })
    write_table(c, options)
  end

  private

  def write_table(csv, options = {})
    # TODO: if file exists prompt to overwrite
    options['output_file'].tap do |filename|
      puts "writing to #{filename}"
      File.write(filename, csv.to_s)
    end
  end

  def read_table(csv, options = {})
    raise "can't find #{csv}" unless File.exist?(csv)
    raise "file #{csv} is not a CSV file!" unless File.extname(csv) == '.csv'
    CSV.new(File.read(csv), headers: true, row_sep: :auto, skip_lines: /\A[,\s]*\z/).read
  end

  def put_stats(stats)
    # k_padding is the number of characters in the longest key
    k_padding = stats.keys.map(&:length).reduce { |a, b| a > b ? a : b }
    stats.each { |k, v| puts "  #{k.to_s.rjust(k_padding, ' ')}: #{v}" }
  end
end

CSVP.start(ARGV)
